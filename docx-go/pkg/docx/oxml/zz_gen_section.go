// Code generated by codegen; DO NOT EDIT.

package oxml

import (
	"fmt"
	"github.com/user/go-docx/pkg/docx/enum"
)

// Ensure imports are used.
var _ = fmt.Sprintf

// --- CT_SectPr ---

// CT_SectPr — section properties element
type CT_SectPr struct {
	Element
}

// Type returns the <w:type> child element, or nil if not present.
func (e *CT_SectPr) Type() *CT_SectType {
	child := e.FindChild("w:type")
	if child == nil {
		return nil
	}
	return &CT_SectType{Element{E: child}}
}

// GetOrAddType returns <w:type>, creating it if not present.
func (e *CT_SectPr) GetOrAddType() *CT_SectType {
	child := e.Type()
	if child != nil {
		return child
	}
	return e.addType()
}

// RemoveType removes all <w:type> child elements.
func (e *CT_SectPr) RemoveType() {
	e.RemoveAll("w:type")
}

// addType adds a new <w:type> in correct sequence.
func (e *CT_SectPr) addType() *CT_SectType {
	child := e.newType()
	e.insertType(child)
	return child
}

// newType creates a detached <w:type> element.
func (e *CT_SectPr) newType() *CT_SectType {
	el := OxmlElement("w:type")
	return &CT_SectType{Element{E: el}}
}

// insertType inserts child before first successor.
func (e *CT_SectPr) insertType(child *CT_SectType) *CT_SectType {
	e.InsertElementBefore(child.E, "w:pgSz", "w:pgMar", "w:paperSrc", "w:pgBorders", "w:lnNumType", "w:pgNumType", "w:cols", "w:formProt", "w:vAlign", "w:noEndnote", "w:titlePg", "w:textDirection", "w:bidi", "w:rtlGutter", "w:docGrid", "w:printerSettings", "w:sectPrChange")
	return child
}

// PgSz returns the <w:pgSz> child element, or nil if not present.
func (e *CT_SectPr) PgSz() *CT_PageSz {
	child := e.FindChild("w:pgSz")
	if child == nil {
		return nil
	}
	return &CT_PageSz{Element{E: child}}
}

// GetOrAddPgSz returns <w:pgSz>, creating it if not present.
func (e *CT_SectPr) GetOrAddPgSz() *CT_PageSz {
	child := e.PgSz()
	if child != nil {
		return child
	}
	return e.addPgSz()
}

// RemovePgSz removes all <w:pgSz> child elements.
func (e *CT_SectPr) RemovePgSz() {
	e.RemoveAll("w:pgSz")
}

// addPgSz adds a new <w:pgSz> in correct sequence.
func (e *CT_SectPr) addPgSz() *CT_PageSz {
	child := e.newPgSz()
	e.insertPgSz(child)
	return child
}

// newPgSz creates a detached <w:pgSz> element.
func (e *CT_SectPr) newPgSz() *CT_PageSz {
	el := OxmlElement("w:pgSz")
	return &CT_PageSz{Element{E: el}}
}

// insertPgSz inserts child before first successor.
func (e *CT_SectPr) insertPgSz(child *CT_PageSz) *CT_PageSz {
	e.InsertElementBefore(child.E, "w:pgMar", "w:paperSrc", "w:pgBorders", "w:lnNumType", "w:pgNumType", "w:cols", "w:formProt", "w:vAlign", "w:noEndnote", "w:titlePg", "w:textDirection", "w:bidi", "w:rtlGutter", "w:docGrid", "w:printerSettings", "w:sectPrChange")
	return child
}

// PgMar returns the <w:pgMar> child element, or nil if not present.
func (e *CT_SectPr) PgMar() *CT_PageMar {
	child := e.FindChild("w:pgMar")
	if child == nil {
		return nil
	}
	return &CT_PageMar{Element{E: child}}
}

// GetOrAddPgMar returns <w:pgMar>, creating it if not present.
func (e *CT_SectPr) GetOrAddPgMar() *CT_PageMar {
	child := e.PgMar()
	if child != nil {
		return child
	}
	return e.addPgMar()
}

// RemovePgMar removes all <w:pgMar> child elements.
func (e *CT_SectPr) RemovePgMar() {
	e.RemoveAll("w:pgMar")
}

// addPgMar adds a new <w:pgMar> in correct sequence.
func (e *CT_SectPr) addPgMar() *CT_PageMar {
	child := e.newPgMar()
	e.insertPgMar(child)
	return child
}

// newPgMar creates a detached <w:pgMar> element.
func (e *CT_SectPr) newPgMar() *CT_PageMar {
	el := OxmlElement("w:pgMar")
	return &CT_PageMar{Element{E: el}}
}

// insertPgMar inserts child before first successor.
func (e *CT_SectPr) insertPgMar(child *CT_PageMar) *CT_PageMar {
	e.InsertElementBefore(child.E, "w:paperSrc", "w:pgBorders", "w:lnNumType", "w:pgNumType", "w:cols", "w:formProt", "w:vAlign", "w:noEndnote", "w:titlePg", "w:textDirection", "w:bidi", "w:rtlGutter", "w:docGrid", "w:printerSettings", "w:sectPrChange")
	return child
}

// TitlePg returns the <w:titlePg> child element, or nil if not present.
func (e *CT_SectPr) TitlePg() *CT_OnOff {
	child := e.FindChild("w:titlePg")
	if child == nil {
		return nil
	}
	return &CT_OnOff{Element{E: child}}
}

// GetOrAddTitlePg returns <w:titlePg>, creating it if not present.
func (e *CT_SectPr) GetOrAddTitlePg() *CT_OnOff {
	child := e.TitlePg()
	if child != nil {
		return child
	}
	return e.addTitlePg()
}

// RemoveTitlePg removes all <w:titlePg> child elements.
func (e *CT_SectPr) RemoveTitlePg() {
	e.RemoveAll("w:titlePg")
}

// addTitlePg adds a new <w:titlePg> in correct sequence.
func (e *CT_SectPr) addTitlePg() *CT_OnOff {
	child := e.newTitlePg()
	e.insertTitlePg(child)
	return child
}

// newTitlePg creates a detached <w:titlePg> element.
func (e *CT_SectPr) newTitlePg() *CT_OnOff {
	el := OxmlElement("w:titlePg")
	return &CT_OnOff{Element{E: el}}
}

// insertTitlePg inserts child before first successor.
func (e *CT_SectPr) insertTitlePg(child *CT_OnOff) *CT_OnOff {
	e.InsertElementBefore(child.E, "w:textDirection", "w:bidi", "w:rtlGutter", "w:docGrid", "w:printerSettings", "w:sectPrChange")
	return child
}

// HeaderReferenceList returns all <w:headerReference> child elements.
func (e *CT_SectPr) HeaderReferenceList() []*CT_HdrFtrRef {
	children := e.FindAllChildren("w:headerReference")
	result := make([]*CT_HdrFtrRef, len(children))
	for i, c := range children {
		result[i] = &CT_HdrFtrRef{Element{E: c}}
	}
	return result
}

// AddHeaderReference adds a new <w:headerReference> in correct sequence.
func (e *CT_SectPr) AddHeaderReference() *CT_HdrFtrRef {
	return e.addHeaderReference()
}

// addHeaderReference adds a new <w:headerReference> unconditionally in correct sequence.
func (e *CT_SectPr) addHeaderReference() *CT_HdrFtrRef {
	child := e.newHeaderReference()
	e.insertHeaderReference(child)
	return child
}

// newHeaderReference creates a detached <w:headerReference> element.
func (e *CT_SectPr) newHeaderReference() *CT_HdrFtrRef {
	el := OxmlElement("w:headerReference")
	return &CT_HdrFtrRef{Element{E: el}}
}

// insertHeaderReference inserts child before first successor.
func (e *CT_SectPr) insertHeaderReference(child *CT_HdrFtrRef) *CT_HdrFtrRef {
	e.InsertElementBefore(child.E, "w:footnotePr", "w:endnotePr", "w:type", "w:pgSz", "w:pgMar", "w:paperSrc", "w:pgBorders", "w:lnNumType", "w:pgNumType", "w:cols", "w:formProt", "w:vAlign", "w:noEndnote", "w:titlePg", "w:textDirection", "w:bidi", "w:rtlGutter", "w:docGrid", "w:printerSettings", "w:sectPrChange")
	return child
}

// FooterReferenceList returns all <w:footerReference> child elements.
func (e *CT_SectPr) FooterReferenceList() []*CT_HdrFtrRef {
	children := e.FindAllChildren("w:footerReference")
	result := make([]*CT_HdrFtrRef, len(children))
	for i, c := range children {
		result[i] = &CT_HdrFtrRef{Element{E: c}}
	}
	return result
}

// AddFooterReference adds a new <w:footerReference> in correct sequence.
func (e *CT_SectPr) AddFooterReference() *CT_HdrFtrRef {
	return e.addFooterReference()
}

// addFooterReference adds a new <w:footerReference> unconditionally in correct sequence.
func (e *CT_SectPr) addFooterReference() *CT_HdrFtrRef {
	child := e.newFooterReference()
	e.insertFooterReference(child)
	return child
}

// newFooterReference creates a detached <w:footerReference> element.
func (e *CT_SectPr) newFooterReference() *CT_HdrFtrRef {
	el := OxmlElement("w:footerReference")
	return &CT_HdrFtrRef{Element{E: el}}
}

// insertFooterReference inserts child before first successor.
func (e *CT_SectPr) insertFooterReference(child *CT_HdrFtrRef) *CT_HdrFtrRef {
	e.InsertElementBefore(child.E, "w:footnotePr", "w:endnotePr", "w:type", "w:pgSz", "w:pgMar", "w:paperSrc", "w:pgBorders", "w:lnNumType", "w:pgNumType", "w:cols", "w:formProt", "w:vAlign", "w:noEndnote", "w:titlePg", "w:textDirection", "w:bidi", "w:rtlGutter", "w:docGrid", "w:printerSettings", "w:sectPrChange")
	return child
}

// --- CT_HdrFtr ---

// CT_HdrFtr — header/footer element
type CT_HdrFtr struct {
	Element
}

// PList returns all <w:p> child elements.
func (e *CT_HdrFtr) PList() []*CT_P {
	children := e.FindAllChildren("w:p")
	result := make([]*CT_P, len(children))
	for i, c := range children {
		result[i] = &CT_P{Element{E: c}}
	}
	return result
}

// AddP adds a new <w:p> in correct sequence.
func (e *CT_HdrFtr) AddP() *CT_P {
	return e.addP()
}

// addP adds a new <w:p> unconditionally in correct sequence.
func (e *CT_HdrFtr) addP() *CT_P {
	child := e.newP()
	e.insertP(child)
	return child
}

// newP creates a detached <w:p> element.
func (e *CT_HdrFtr) newP() *CT_P {
	el := OxmlElement("w:p")
	return &CT_P{Element{E: el}}
}

// insertP inserts child before first successor.
func (e *CT_HdrFtr) insertP(child *CT_P) *CT_P {
	e.InsertElementBefore(child.E)
	return child
}

// TblList returns all <w:tbl> child elements.
func (e *CT_HdrFtr) TblList() []*CT_Tbl {
	children := e.FindAllChildren("w:tbl")
	result := make([]*CT_Tbl, len(children))
	for i, c := range children {
		result[i] = &CT_Tbl{Element{E: c}}
	}
	return result
}

// AddTbl adds a new <w:tbl> in correct sequence.
func (e *CT_HdrFtr) AddTbl() *CT_Tbl {
	return e.addTbl()
}

// addTbl adds a new <w:tbl> unconditionally in correct sequence.
func (e *CT_HdrFtr) addTbl() *CT_Tbl {
	child := e.newTbl()
	e.insertTbl(child)
	return child
}

// newTbl creates a detached <w:tbl> element.
func (e *CT_HdrFtr) newTbl() *CT_Tbl {
	el := OxmlElement("w:tbl")
	return &CT_Tbl{Element{E: el}}
}

// insertTbl inserts child before first successor.
func (e *CT_HdrFtr) insertTbl(child *CT_Tbl) *CT_Tbl {
	e.InsertElementBefore(child.E)
	return child
}

// --- CT_HdrFtrRef ---

// CT_HdrFtrRef — header/footer reference element
type CT_HdrFtrRef struct {
	Element
}

// Type returns the value of the required "w:type" attribute.
func (e *CT_HdrFtrRef) Type() (enum.WdHeaderFooterIndex, error) {
	val, ok := e.GetAttr("w:type")
	if !ok {
		return enum.WdHeaderFooterIndex(0), fmt.Errorf("required attribute %q not present on <%s>", "w:type", e.Tag())
	}
	parsed, err := parseEnum(val, enum.WdHeaderFooterIndexFromXml)
	if err != nil {
		return enum.WdHeaderFooterIndex(0), &ParseAttrError{Element: e.Tag(), Attr: "w:type", RawValue: val, Err: err}
	}
	return parsed, nil
}

// SetType sets the required "w:type" attribute.
func (e *CT_HdrFtrRef) SetType(v enum.WdHeaderFooterIndex) error {
	s, err := v.ToXml()
	if err != nil {
		return fmt.Errorf("CT_HdrFtrRef.SetType: %w", err)
	}
	e.SetAttr("w:type", s)
	return nil
}

// RId returns the value of the required "r:id" attribute.
func (e *CT_HdrFtrRef) RId() (string, error) {
	val, ok := e.GetAttr("r:id")
	if !ok {
		return "", fmt.Errorf("required attribute %q not present on <%s>", "r:id", e.Tag())
	}
	return val, nil
}

// SetRId sets the required "r:id" attribute.
func (e *CT_HdrFtrRef) SetRId(v string) error {
	s, err := formatStringAttr(v)
	if err != nil {
		return fmt.Errorf("CT_HdrFtrRef.SetRId: %w", err)
	}
	e.SetAttr("r:id", s)
	return nil
}

// --- CT_PageMar ---

// CT_PageMar — page margins element
type CT_PageMar struct {
	Element
}

// Top returns the value of the "w:top" attribute, or nil if absent.
// Returns an error if the attribute is present but cannot be parsed.
func (e *CT_PageMar) Top() (*int, error) {
	val, ok := e.GetAttr("w:top")
	if !ok {
		return nil, nil
	}
	parsed, err := parseIntAttr(val)
	if err != nil {
		return nil, &ParseAttrError{Element: e.Tag(), Attr: "w:top", RawValue: val, Err: err}
	}
	return &parsed, nil
}

// SetTop sets the "w:top" attribute.
// Passing nil removes it.
func (e *CT_PageMar) SetTop(v *int) error {
	if v == nil {
		e.RemoveAttr("w:top")
		return nil
	}
	s, err := formatIntAttr(*v)
	if err != nil {
		return fmt.Errorf("CT_PageMar.SetTop: %w", err)
	}
	e.SetAttr("w:top", s)
	return nil
}

// Right returns the value of the "w:right" attribute, or nil if absent.
// Returns an error if the attribute is present but cannot be parsed.
func (e *CT_PageMar) Right() (*int, error) {
	val, ok := e.GetAttr("w:right")
	if !ok {
		return nil, nil
	}
	parsed, err := parseIntAttr(val)
	if err != nil {
		return nil, &ParseAttrError{Element: e.Tag(), Attr: "w:right", RawValue: val, Err: err}
	}
	return &parsed, nil
}

// SetRight sets the "w:right" attribute.
// Passing nil removes it.
func (e *CT_PageMar) SetRight(v *int) error {
	if v == nil {
		e.RemoveAttr("w:right")
		return nil
	}
	s, err := formatIntAttr(*v)
	if err != nil {
		return fmt.Errorf("CT_PageMar.SetRight: %w", err)
	}
	e.SetAttr("w:right", s)
	return nil
}

// Bottom returns the value of the "w:bottom" attribute, or nil if absent.
// Returns an error if the attribute is present but cannot be parsed.
func (e *CT_PageMar) Bottom() (*int, error) {
	val, ok := e.GetAttr("w:bottom")
	if !ok {
		return nil, nil
	}
	parsed, err := parseIntAttr(val)
	if err != nil {
		return nil, &ParseAttrError{Element: e.Tag(), Attr: "w:bottom", RawValue: val, Err: err}
	}
	return &parsed, nil
}

// SetBottom sets the "w:bottom" attribute.
// Passing nil removes it.
func (e *CT_PageMar) SetBottom(v *int) error {
	if v == nil {
		e.RemoveAttr("w:bottom")
		return nil
	}
	s, err := formatIntAttr(*v)
	if err != nil {
		return fmt.Errorf("CT_PageMar.SetBottom: %w", err)
	}
	e.SetAttr("w:bottom", s)
	return nil
}

// Left returns the value of the "w:left" attribute, or nil if absent.
// Returns an error if the attribute is present but cannot be parsed.
func (e *CT_PageMar) Left() (*int, error) {
	val, ok := e.GetAttr("w:left")
	if !ok {
		return nil, nil
	}
	parsed, err := parseIntAttr(val)
	if err != nil {
		return nil, &ParseAttrError{Element: e.Tag(), Attr: "w:left", RawValue: val, Err: err}
	}
	return &parsed, nil
}

// SetLeft sets the "w:left" attribute.
// Passing nil removes it.
func (e *CT_PageMar) SetLeft(v *int) error {
	if v == nil {
		e.RemoveAttr("w:left")
		return nil
	}
	s, err := formatIntAttr(*v)
	if err != nil {
		return fmt.Errorf("CT_PageMar.SetLeft: %w", err)
	}
	e.SetAttr("w:left", s)
	return nil
}

// Header returns the value of the "w:header" attribute, or nil if absent.
// Returns an error if the attribute is present but cannot be parsed.
func (e *CT_PageMar) Header() (*int, error) {
	val, ok := e.GetAttr("w:header")
	if !ok {
		return nil, nil
	}
	parsed, err := parseIntAttr(val)
	if err != nil {
		return nil, &ParseAttrError{Element: e.Tag(), Attr: "w:header", RawValue: val, Err: err}
	}
	return &parsed, nil
}

// SetHeader sets the "w:header" attribute.
// Passing nil removes it.
func (e *CT_PageMar) SetHeader(v *int) error {
	if v == nil {
		e.RemoveAttr("w:header")
		return nil
	}
	s, err := formatIntAttr(*v)
	if err != nil {
		return fmt.Errorf("CT_PageMar.SetHeader: %w", err)
	}
	e.SetAttr("w:header", s)
	return nil
}

// Footer returns the value of the "w:footer" attribute, or nil if absent.
// Returns an error if the attribute is present but cannot be parsed.
func (e *CT_PageMar) Footer() (*int, error) {
	val, ok := e.GetAttr("w:footer")
	if !ok {
		return nil, nil
	}
	parsed, err := parseIntAttr(val)
	if err != nil {
		return nil, &ParseAttrError{Element: e.Tag(), Attr: "w:footer", RawValue: val, Err: err}
	}
	return &parsed, nil
}

// SetFooter sets the "w:footer" attribute.
// Passing nil removes it.
func (e *CT_PageMar) SetFooter(v *int) error {
	if v == nil {
		e.RemoveAttr("w:footer")
		return nil
	}
	s, err := formatIntAttr(*v)
	if err != nil {
		return fmt.Errorf("CT_PageMar.SetFooter: %w", err)
	}
	e.SetAttr("w:footer", s)
	return nil
}

// Gutter returns the value of the "w:gutter" attribute, or nil if absent.
// Returns an error if the attribute is present but cannot be parsed.
func (e *CT_PageMar) Gutter() (*int, error) {
	val, ok := e.GetAttr("w:gutter")
	if !ok {
		return nil, nil
	}
	parsed, err := parseIntAttr(val)
	if err != nil {
		return nil, &ParseAttrError{Element: e.Tag(), Attr: "w:gutter", RawValue: val, Err: err}
	}
	return &parsed, nil
}

// SetGutter sets the "w:gutter" attribute.
// Passing nil removes it.
func (e *CT_PageMar) SetGutter(v *int) error {
	if v == nil {
		e.RemoveAttr("w:gutter")
		return nil
	}
	s, err := formatIntAttr(*v)
	if err != nil {
		return fmt.Errorf("CT_PageMar.SetGutter: %w", err)
	}
	e.SetAttr("w:gutter", s)
	return nil
}

// --- CT_PageSz ---

// CT_PageSz — page size element
type CT_PageSz struct {
	Element
}

// W returns the value of the "w:w" attribute, or nil if absent.
// Returns an error if the attribute is present but cannot be parsed.
func (e *CT_PageSz) W() (*int, error) {
	val, ok := e.GetAttr("w:w")
	if !ok {
		return nil, nil
	}
	parsed, err := parseIntAttr(val)
	if err != nil {
		return nil, &ParseAttrError{Element: e.Tag(), Attr: "w:w", RawValue: val, Err: err}
	}
	return &parsed, nil
}

// SetW sets the "w:w" attribute.
// Passing nil removes it.
func (e *CT_PageSz) SetW(v *int) error {
	if v == nil {
		e.RemoveAttr("w:w")
		return nil
	}
	s, err := formatIntAttr(*v)
	if err != nil {
		return fmt.Errorf("CT_PageSz.SetW: %w", err)
	}
	e.SetAttr("w:w", s)
	return nil
}

// H returns the value of the "w:h" attribute, or nil if absent.
// Returns an error if the attribute is present but cannot be parsed.
func (e *CT_PageSz) H() (*int, error) {
	val, ok := e.GetAttr("w:h")
	if !ok {
		return nil, nil
	}
	parsed, err := parseIntAttr(val)
	if err != nil {
		return nil, &ParseAttrError{Element: e.Tag(), Attr: "w:h", RawValue: val, Err: err}
	}
	return &parsed, nil
}

// SetH sets the "w:h" attribute.
// Passing nil removes it.
func (e *CT_PageSz) SetH(v *int) error {
	if v == nil {
		e.RemoveAttr("w:h")
		return nil
	}
	s, err := formatIntAttr(*v)
	if err != nil {
		return fmt.Errorf("CT_PageSz.SetH: %w", err)
	}
	e.SetAttr("w:h", s)
	return nil
}

// Orient returns the value of the "w:orient" attribute, or enum.WdOrientation(0) if absent.
// Returns an error if the attribute is present but cannot be parsed.
func (e *CT_PageSz) Orient() (enum.WdOrientation, error) {
	val, ok := e.GetAttr("w:orient")
	if !ok {
		return enum.WdOrientation(0), nil
	}
	parsed, err := parseEnum(val, enum.WdOrientationFromXml)
	if err != nil {
		return enum.WdOrientation(0), &ParseAttrError{Element: e.Tag(), Attr: "w:orient", RawValue: val, Err: err}
	}
	return parsed, nil
}

// SetOrient sets the "w:orient" attribute.
// Passing enum.WdOrientation(0) removes it.
func (e *CT_PageSz) SetOrient(v enum.WdOrientation) error {
	if v == enum.WdOrientation(0) {
		e.RemoveAttr("w:orient")
		return nil
	}
	s, err := v.ToXml()
	if err != nil {
		return fmt.Errorf("CT_PageSz.SetOrient: %w", err)
	}
	e.SetAttr("w:orient", s)
	return nil
}

// --- CT_SectType ---

// CT_SectType — section type element
type CT_SectType struct {
	Element
}

// Val returns the value of the "w:val" attribute, or enum.WdSectionStart(0) if absent.
// Returns an error if the attribute is present but cannot be parsed.
func (e *CT_SectType) Val() (enum.WdSectionStart, error) {
	val, ok := e.GetAttr("w:val")
	if !ok {
		return enum.WdSectionStart(0), nil
	}
	parsed, err := parseEnum(val, enum.WdSectionStartFromXml)
	if err != nil {
		return enum.WdSectionStart(0), &ParseAttrError{Element: e.Tag(), Attr: "w:val", RawValue: val, Err: err}
	}
	return parsed, nil
}

// SetVal sets the "w:val" attribute.
// Passing enum.WdSectionStart(0) removes it.
func (e *CT_SectType) SetVal(v enum.WdSectionStart) error {
	if v == enum.WdSectionStart(0) {
		e.RemoveAttr("w:val")
		return nil
	}
	s, err := v.ToXml()
	if err != nil {
		return fmt.Errorf("CT_SectType.SetVal: %w", err)
	}
	e.SetAttr("w:val", s)
	return nil
}
