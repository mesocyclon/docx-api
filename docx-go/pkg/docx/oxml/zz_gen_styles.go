// Code generated by codegen; DO NOT EDIT.

package oxml

import (
	"fmt"
)

// Ensure imports are used.
var _ = fmt.Sprintf

// --- CT_Styles ---

// CT_Styles — styles root element
type CT_Styles struct {
	Element
}

// LatentStyles returns the <w:latentStyles> child element, or nil if not present.
func (e *CT_Styles) LatentStyles() *CT_LatentStyles {
	child := e.FindChild("w:latentStyles")
	if child == nil {
		return nil
	}
	return &CT_LatentStyles{Element{E: child}}
}

// GetOrAddLatentStyles returns <w:latentStyles>, creating it if not present.
func (e *CT_Styles) GetOrAddLatentStyles() *CT_LatentStyles {
	child := e.LatentStyles()
	if child != nil {
		return child
	}
	return e.addLatentStyles()
}

// RemoveLatentStyles removes all <w:latentStyles> child elements.
func (e *CT_Styles) RemoveLatentStyles() {
	e.RemoveAll("w:latentStyles")
}

// addLatentStyles adds a new <w:latentStyles> in correct sequence.
func (e *CT_Styles) addLatentStyles() *CT_LatentStyles {
	child := e.newLatentStyles()
	e.insertLatentStyles(child)
	return child
}

// newLatentStyles creates a detached <w:latentStyles> element.
func (e *CT_Styles) newLatentStyles() *CT_LatentStyles {
	el := OxmlElement("w:latentStyles")
	return &CT_LatentStyles{Element{E: el}}
}

// insertLatentStyles inserts child before first successor.
func (e *CT_Styles) insertLatentStyles(child *CT_LatentStyles) *CT_LatentStyles {
	e.InsertElementBefore(child.E, "w:style")
	return child
}

// StyleList returns all <w:style> child elements.
func (e *CT_Styles) StyleList() []*CT_Style {
	children := e.FindAllChildren("w:style")
	result := make([]*CT_Style, len(children))
	for i, c := range children {
		result[i] = &CT_Style{Element{E: c}}
	}
	return result
}

// AddStyle adds a new <w:style> in correct sequence.
func (e *CT_Styles) AddStyle() *CT_Style {
	return e.addStyle()
}

// addStyle adds a new <w:style> unconditionally in correct sequence.
func (e *CT_Styles) addStyle() *CT_Style {
	child := e.newStyle()
	e.insertStyle(child)
	return child
}

// newStyle creates a detached <w:style> element.
func (e *CT_Styles) newStyle() *CT_Style {
	el := OxmlElement("w:style")
	return &CT_Style{Element{E: el}}
}

// insertStyle inserts child before first successor.
func (e *CT_Styles) insertStyle(child *CT_Style) *CT_Style {
	e.InsertElementBefore(child.E)
	return child
}

// --- CT_Style ---

// CT_Style — style definition element
type CT_Style struct {
	Element
}

// Name returns the <w:name> child element, or nil if not present.
func (e *CT_Style) Name() *CT_String {
	child := e.FindChild("w:name")
	if child == nil {
		return nil
	}
	return &CT_String{Element{E: child}}
}

// GetOrAddName returns <w:name>, creating it if not present.
func (e *CT_Style) GetOrAddName() *CT_String {
	child := e.Name()
	if child != nil {
		return child
	}
	return e.addName()
}

// RemoveName removes all <w:name> child elements.
func (e *CT_Style) RemoveName() {
	e.RemoveAll("w:name")
}

// addName adds a new <w:name> in correct sequence.
func (e *CT_Style) addName() *CT_String {
	child := e.newName()
	e.insertName(child)
	return child
}

// newName creates a detached <w:name> element.
func (e *CT_Style) newName() *CT_String {
	el := OxmlElement("w:name")
	return &CT_String{Element{E: el}}
}

// insertName inserts child before first successor.
func (e *CT_Style) insertName(child *CT_String) *CT_String {
	e.InsertElementBefore(child.E, "w:aliases", "w:basedOn", "w:next", "w:link", "w:autoRedefine", "w:hidden", "w:uiPriority", "w:semiHidden", "w:unhideWhenUsed", "w:qFormat", "w:locked", "w:personal", "w:personalCompose", "w:personalReply", "w:rsid", "w:pPr", "w:rPr", "w:tblPr", "w:trPr", "w:tcPr", "w:tblStylePr")
	return child
}

// BasedOn returns the <w:basedOn> child element, or nil if not present.
func (e *CT_Style) BasedOn() *CT_String {
	child := e.FindChild("w:basedOn")
	if child == nil {
		return nil
	}
	return &CT_String{Element{E: child}}
}

// GetOrAddBasedOn returns <w:basedOn>, creating it if not present.
func (e *CT_Style) GetOrAddBasedOn() *CT_String {
	child := e.BasedOn()
	if child != nil {
		return child
	}
	return e.addBasedOn()
}

// RemoveBasedOn removes all <w:basedOn> child elements.
func (e *CT_Style) RemoveBasedOn() {
	e.RemoveAll("w:basedOn")
}

// addBasedOn adds a new <w:basedOn> in correct sequence.
func (e *CT_Style) addBasedOn() *CT_String {
	child := e.newBasedOn()
	e.insertBasedOn(child)
	return child
}

// newBasedOn creates a detached <w:basedOn> element.
func (e *CT_Style) newBasedOn() *CT_String {
	el := OxmlElement("w:basedOn")
	return &CT_String{Element{E: el}}
}

// insertBasedOn inserts child before first successor.
func (e *CT_Style) insertBasedOn(child *CT_String) *CT_String {
	e.InsertElementBefore(child.E, "w:next", "w:link", "w:autoRedefine", "w:hidden", "w:uiPriority", "w:semiHidden", "w:unhideWhenUsed", "w:qFormat", "w:locked", "w:personal", "w:personalCompose", "w:personalReply", "w:rsid", "w:pPr", "w:rPr", "w:tblPr", "w:trPr", "w:tcPr", "w:tblStylePr")
	return child
}

// Next returns the <w:next> child element, or nil if not present.
func (e *CT_Style) Next() *CT_String {
	child := e.FindChild("w:next")
	if child == nil {
		return nil
	}
	return &CT_String{Element{E: child}}
}

// GetOrAddNext returns <w:next>, creating it if not present.
func (e *CT_Style) GetOrAddNext() *CT_String {
	child := e.Next()
	if child != nil {
		return child
	}
	return e.addNext()
}

// RemoveNext removes all <w:next> child elements.
func (e *CT_Style) RemoveNext() {
	e.RemoveAll("w:next")
}

// addNext adds a new <w:next> in correct sequence.
func (e *CT_Style) addNext() *CT_String {
	child := e.newNext()
	e.insertNext(child)
	return child
}

// newNext creates a detached <w:next> element.
func (e *CT_Style) newNext() *CT_String {
	el := OxmlElement("w:next")
	return &CT_String{Element{E: el}}
}

// insertNext inserts child before first successor.
func (e *CT_Style) insertNext(child *CT_String) *CT_String {
	e.InsertElementBefore(child.E, "w:link", "w:autoRedefine", "w:hidden", "w:uiPriority", "w:semiHidden", "w:unhideWhenUsed", "w:qFormat", "w:locked", "w:personal", "w:personalCompose", "w:personalReply", "w:rsid", "w:pPr", "w:rPr", "w:tblPr", "w:trPr", "w:tcPr", "w:tblStylePr")
	return child
}

// UiPriority returns the <w:uiPriority> child element, or nil if not present.
func (e *CT_Style) UiPriority() *CT_DecimalNumber {
	child := e.FindChild("w:uiPriority")
	if child == nil {
		return nil
	}
	return &CT_DecimalNumber{Element{E: child}}
}

// GetOrAddUiPriority returns <w:uiPriority>, creating it if not present.
func (e *CT_Style) GetOrAddUiPriority() *CT_DecimalNumber {
	child := e.UiPriority()
	if child != nil {
		return child
	}
	return e.addUiPriority()
}

// RemoveUiPriority removes all <w:uiPriority> child elements.
func (e *CT_Style) RemoveUiPriority() {
	e.RemoveAll("w:uiPriority")
}

// addUiPriority adds a new <w:uiPriority> in correct sequence.
func (e *CT_Style) addUiPriority() *CT_DecimalNumber {
	child := e.newUiPriority()
	e.insertUiPriority(child)
	return child
}

// newUiPriority creates a detached <w:uiPriority> element.
func (e *CT_Style) newUiPriority() *CT_DecimalNumber {
	el := OxmlElement("w:uiPriority")
	return &CT_DecimalNumber{Element{E: el}}
}

// insertUiPriority inserts child before first successor.
func (e *CT_Style) insertUiPriority(child *CT_DecimalNumber) *CT_DecimalNumber {
	e.InsertElementBefore(child.E, "w:semiHidden", "w:unhideWhenUsed", "w:qFormat", "w:locked", "w:personal", "w:personalCompose", "w:personalReply", "w:rsid", "w:pPr", "w:rPr", "w:tblPr", "w:trPr", "w:tcPr", "w:tblStylePr")
	return child
}

// SemiHidden returns the <w:semiHidden> child element, or nil if not present.
func (e *CT_Style) SemiHidden() *CT_OnOff {
	child := e.FindChild("w:semiHidden")
	if child == nil {
		return nil
	}
	return &CT_OnOff{Element{E: child}}
}

// GetOrAddSemiHidden returns <w:semiHidden>, creating it if not present.
func (e *CT_Style) GetOrAddSemiHidden() *CT_OnOff {
	child := e.SemiHidden()
	if child != nil {
		return child
	}
	return e.addSemiHidden()
}

// RemoveSemiHidden removes all <w:semiHidden> child elements.
func (e *CT_Style) RemoveSemiHidden() {
	e.RemoveAll("w:semiHidden")
}

// addSemiHidden adds a new <w:semiHidden> in correct sequence.
func (e *CT_Style) addSemiHidden() *CT_OnOff {
	child := e.newSemiHidden()
	e.insertSemiHidden(child)
	return child
}

// newSemiHidden creates a detached <w:semiHidden> element.
func (e *CT_Style) newSemiHidden() *CT_OnOff {
	el := OxmlElement("w:semiHidden")
	return &CT_OnOff{Element{E: el}}
}

// insertSemiHidden inserts child before first successor.
func (e *CT_Style) insertSemiHidden(child *CT_OnOff) *CT_OnOff {
	e.InsertElementBefore(child.E, "w:unhideWhenUsed", "w:qFormat", "w:locked", "w:personal", "w:personalCompose", "w:personalReply", "w:rsid", "w:pPr", "w:rPr", "w:tblPr", "w:trPr", "w:tcPr", "w:tblStylePr")
	return child
}

// UnhideWhenUsed returns the <w:unhideWhenUsed> child element, or nil if not present.
func (e *CT_Style) UnhideWhenUsed() *CT_OnOff {
	child := e.FindChild("w:unhideWhenUsed")
	if child == nil {
		return nil
	}
	return &CT_OnOff{Element{E: child}}
}

// GetOrAddUnhideWhenUsed returns <w:unhideWhenUsed>, creating it if not present.
func (e *CT_Style) GetOrAddUnhideWhenUsed() *CT_OnOff {
	child := e.UnhideWhenUsed()
	if child != nil {
		return child
	}
	return e.addUnhideWhenUsed()
}

// RemoveUnhideWhenUsed removes all <w:unhideWhenUsed> child elements.
func (e *CT_Style) RemoveUnhideWhenUsed() {
	e.RemoveAll("w:unhideWhenUsed")
}

// addUnhideWhenUsed adds a new <w:unhideWhenUsed> in correct sequence.
func (e *CT_Style) addUnhideWhenUsed() *CT_OnOff {
	child := e.newUnhideWhenUsed()
	e.insertUnhideWhenUsed(child)
	return child
}

// newUnhideWhenUsed creates a detached <w:unhideWhenUsed> element.
func (e *CT_Style) newUnhideWhenUsed() *CT_OnOff {
	el := OxmlElement("w:unhideWhenUsed")
	return &CT_OnOff{Element{E: el}}
}

// insertUnhideWhenUsed inserts child before first successor.
func (e *CT_Style) insertUnhideWhenUsed(child *CT_OnOff) *CT_OnOff {
	e.InsertElementBefore(child.E, "w:qFormat", "w:locked", "w:personal", "w:personalCompose", "w:personalReply", "w:rsid", "w:pPr", "w:rPr", "w:tblPr", "w:trPr", "w:tcPr", "w:tblStylePr")
	return child
}

// QFormat returns the <w:qFormat> child element, or nil if not present.
func (e *CT_Style) QFormat() *CT_OnOff {
	child := e.FindChild("w:qFormat")
	if child == nil {
		return nil
	}
	return &CT_OnOff{Element{E: child}}
}

// GetOrAddQFormat returns <w:qFormat>, creating it if not present.
func (e *CT_Style) GetOrAddQFormat() *CT_OnOff {
	child := e.QFormat()
	if child != nil {
		return child
	}
	return e.addQFormat()
}

// RemoveQFormat removes all <w:qFormat> child elements.
func (e *CT_Style) RemoveQFormat() {
	e.RemoveAll("w:qFormat")
}

// addQFormat adds a new <w:qFormat> in correct sequence.
func (e *CT_Style) addQFormat() *CT_OnOff {
	child := e.newQFormat()
	e.insertQFormat(child)
	return child
}

// newQFormat creates a detached <w:qFormat> element.
func (e *CT_Style) newQFormat() *CT_OnOff {
	el := OxmlElement("w:qFormat")
	return &CT_OnOff{Element{E: el}}
}

// insertQFormat inserts child before first successor.
func (e *CT_Style) insertQFormat(child *CT_OnOff) *CT_OnOff {
	e.InsertElementBefore(child.E, "w:locked", "w:personal", "w:personalCompose", "w:personalReply", "w:rsid", "w:pPr", "w:rPr", "w:tblPr", "w:trPr", "w:tcPr", "w:tblStylePr")
	return child
}

// Locked returns the <w:locked> child element, or nil if not present.
func (e *CT_Style) Locked() *CT_OnOff {
	child := e.FindChild("w:locked")
	if child == nil {
		return nil
	}
	return &CT_OnOff{Element{E: child}}
}

// GetOrAddLocked returns <w:locked>, creating it if not present.
func (e *CT_Style) GetOrAddLocked() *CT_OnOff {
	child := e.Locked()
	if child != nil {
		return child
	}
	return e.addLocked()
}

// RemoveLocked removes all <w:locked> child elements.
func (e *CT_Style) RemoveLocked() {
	e.RemoveAll("w:locked")
}

// addLocked adds a new <w:locked> in correct sequence.
func (e *CT_Style) addLocked() *CT_OnOff {
	child := e.newLocked()
	e.insertLocked(child)
	return child
}

// newLocked creates a detached <w:locked> element.
func (e *CT_Style) newLocked() *CT_OnOff {
	el := OxmlElement("w:locked")
	return &CT_OnOff{Element{E: el}}
}

// insertLocked inserts child before first successor.
func (e *CT_Style) insertLocked(child *CT_OnOff) *CT_OnOff {
	e.InsertElementBefore(child.E, "w:personal", "w:personalCompose", "w:personalReply", "w:rsid", "w:pPr", "w:rPr", "w:tblPr", "w:trPr", "w:tcPr", "w:tblStylePr")
	return child
}

// PPr returns the <w:pPr> child element, or nil if not present.
func (e *CT_Style) PPr() *CT_PPr {
	child := e.FindChild("w:pPr")
	if child == nil {
		return nil
	}
	return &CT_PPr{Element{E: child}}
}

// GetOrAddPPr returns <w:pPr>, creating it if not present.
func (e *CT_Style) GetOrAddPPr() *CT_PPr {
	child := e.PPr()
	if child != nil {
		return child
	}
	return e.addPPr()
}

// RemovePPr removes all <w:pPr> child elements.
func (e *CT_Style) RemovePPr() {
	e.RemoveAll("w:pPr")
}

// addPPr adds a new <w:pPr> in correct sequence.
func (e *CT_Style) addPPr() *CT_PPr {
	child := e.newPPr()
	e.insertPPr(child)
	return child
}

// newPPr creates a detached <w:pPr> element.
func (e *CT_Style) newPPr() *CT_PPr {
	el := OxmlElement("w:pPr")
	return &CT_PPr{Element{E: el}}
}

// insertPPr inserts child before first successor.
func (e *CT_Style) insertPPr(child *CT_PPr) *CT_PPr {
	e.InsertElementBefore(child.E, "w:rPr", "w:tblPr", "w:trPr", "w:tcPr", "w:tblStylePr")
	return child
}

// RPr returns the <w:rPr> child element, or nil if not present.
func (e *CT_Style) RPr() *CT_RPr {
	child := e.FindChild("w:rPr")
	if child == nil {
		return nil
	}
	return &CT_RPr{Element{E: child}}
}

// GetOrAddRPr returns <w:rPr>, creating it if not present.
func (e *CT_Style) GetOrAddRPr() *CT_RPr {
	child := e.RPr()
	if child != nil {
		return child
	}
	return e.addRPr()
}

// RemoveRPr removes all <w:rPr> child elements.
func (e *CT_Style) RemoveRPr() {
	e.RemoveAll("w:rPr")
}

// addRPr adds a new <w:rPr> in correct sequence.
func (e *CT_Style) addRPr() *CT_RPr {
	child := e.newRPr()
	e.insertRPr(child)
	return child
}

// newRPr creates a detached <w:rPr> element.
func (e *CT_Style) newRPr() *CT_RPr {
	el := OxmlElement("w:rPr")
	return &CT_RPr{Element{E: el}}
}

// insertRPr inserts child before first successor.
func (e *CT_Style) insertRPr(child *CT_RPr) *CT_RPr {
	e.InsertElementBefore(child.E, "w:tblPr", "w:trPr", "w:tcPr", "w:tblStylePr")
	return child
}

// Type returns the value of the "w:type" attribute, or "" if absent.
func (e *CT_Style) Type() string {
	val, ok := e.GetAttr("w:type")
	if !ok {
		return ""
	}
	return val
}

// SetType sets the "w:type" attribute.
// Passing "" removes it.
func (e *CT_Style) SetType(v string) error {
	if v == "" {
		e.RemoveAttr("w:type")
		return nil
	}
	s, err := formatStringAttr(v)
	if err != nil {
		return fmt.Errorf("CT_Style.SetType: %w", err)
	}
	e.SetAttr("w:type", s)
	return nil
}

// StyleId returns the value of the "w:styleId" attribute, or "" if absent.
func (e *CT_Style) StyleId() string {
	val, ok := e.GetAttr("w:styleId")
	if !ok {
		return ""
	}
	return val
}

// SetStyleId sets the "w:styleId" attribute.
// Passing "" removes it.
func (e *CT_Style) SetStyleId(v string) error {
	if v == "" {
		e.RemoveAttr("w:styleId")
		return nil
	}
	s, err := formatStringAttr(v)
	if err != nil {
		return fmt.Errorf("CT_Style.SetStyleId: %w", err)
	}
	e.SetAttr("w:styleId", s)
	return nil
}

// Default returns the value of the "w:default" attribute, or false if absent.
func (e *CT_Style) Default() bool {
	val, ok := e.GetAttr("w:default")
	if !ok {
		return false
	}
	return parseBoolAttr(val)
}

// SetDefault sets the "w:default" attribute.
// Passing false removes it.
func (e *CT_Style) SetDefault(v bool) error {
	if v == false {
		e.RemoveAttr("w:default")
		return nil
	}
	s, err := formatBoolAttr(v)
	if err != nil {
		return fmt.Errorf("CT_Style.SetDefault: %w", err)
	}
	e.SetAttr("w:default", s)
	return nil
}

// CustomStyle returns the value of the "w:customStyle" attribute, or false if absent.
func (e *CT_Style) CustomStyle() bool {
	val, ok := e.GetAttr("w:customStyle")
	if !ok {
		return false
	}
	return parseBoolAttr(val)
}

// SetCustomStyle sets the "w:customStyle" attribute.
// Passing false removes it.
func (e *CT_Style) SetCustomStyle(v bool) error {
	if v == false {
		e.RemoveAttr("w:customStyle")
		return nil
	}
	s, err := formatBoolAttr(v)
	if err != nil {
		return fmt.Errorf("CT_Style.SetCustomStyle: %w", err)
	}
	e.SetAttr("w:customStyle", s)
	return nil
}

// --- CT_LatentStyles ---

// CT_LatentStyles — latent styles element
type CT_LatentStyles struct {
	Element
}

// LsdExceptionList returns all <w:lsdException> child elements.
func (e *CT_LatentStyles) LsdExceptionList() []*CT_LsdException {
	children := e.FindAllChildren("w:lsdException")
	result := make([]*CT_LsdException, len(children))
	for i, c := range children {
		result[i] = &CT_LsdException{Element{E: c}}
	}
	return result
}

// AddLsdException adds a new <w:lsdException> in correct sequence.
func (e *CT_LatentStyles) AddLsdException() *CT_LsdException {
	return e.addLsdException()
}

// addLsdException adds a new <w:lsdException> unconditionally in correct sequence.
func (e *CT_LatentStyles) addLsdException() *CT_LsdException {
	child := e.newLsdException()
	e.insertLsdException(child)
	return child
}

// newLsdException creates a detached <w:lsdException> element.
func (e *CT_LatentStyles) newLsdException() *CT_LsdException {
	el := OxmlElement("w:lsdException")
	return &CT_LsdException{Element{E: el}}
}

// insertLsdException inserts child before first successor.
func (e *CT_LatentStyles) insertLsdException(child *CT_LsdException) *CT_LsdException {
	e.InsertElementBefore(child.E)
	return child
}

// Count returns the value of the "w:count" attribute, or 0 if absent.
// Returns an error if the attribute is present but cannot be parsed.
func (e *CT_LatentStyles) Count() (int, error) {
	val, ok := e.GetAttr("w:count")
	if !ok {
		return 0, nil
	}
	parsed, err := parseIntAttr(val)
	if err != nil {
		return 0, &ParseAttrError{Element: e.Tag(), Attr: "w:count", RawValue: val, Err: err}
	}
	return parsed, nil
}

// SetCount sets the "w:count" attribute.
// Passing 0 removes it.
func (e *CT_LatentStyles) SetCount(v int) error {
	if v == 0 {
		e.RemoveAttr("w:count")
		return nil
	}
	s, err := formatIntAttr(v)
	if err != nil {
		return fmt.Errorf("CT_LatentStyles.SetCount: %w", err)
	}
	e.SetAttr("w:count", s)
	return nil
}

// DefLockedState returns the value of the "w:defLockedState" attribute, or false if absent.
func (e *CT_LatentStyles) DefLockedState() bool {
	val, ok := e.GetAttr("w:defLockedState")
	if !ok {
		return false
	}
	return parseBoolAttr(val)
}

// SetDefLockedState sets the "w:defLockedState" attribute.
// Passing false removes it.
func (e *CT_LatentStyles) SetDefLockedState(v bool) error {
	if v == false {
		e.RemoveAttr("w:defLockedState")
		return nil
	}
	s, err := formatBoolAttr(v)
	if err != nil {
		return fmt.Errorf("CT_LatentStyles.SetDefLockedState: %w", err)
	}
	e.SetAttr("w:defLockedState", s)
	return nil
}

// DefQFormat returns the value of the "w:defQFormat" attribute, or false if absent.
func (e *CT_LatentStyles) DefQFormat() bool {
	val, ok := e.GetAttr("w:defQFormat")
	if !ok {
		return false
	}
	return parseBoolAttr(val)
}

// SetDefQFormat sets the "w:defQFormat" attribute.
// Passing false removes it.
func (e *CT_LatentStyles) SetDefQFormat(v bool) error {
	if v == false {
		e.RemoveAttr("w:defQFormat")
		return nil
	}
	s, err := formatBoolAttr(v)
	if err != nil {
		return fmt.Errorf("CT_LatentStyles.SetDefQFormat: %w", err)
	}
	e.SetAttr("w:defQFormat", s)
	return nil
}

// DefSemiHidden returns the value of the "w:defSemiHidden" attribute, or false if absent.
func (e *CT_LatentStyles) DefSemiHidden() bool {
	val, ok := e.GetAttr("w:defSemiHidden")
	if !ok {
		return false
	}
	return parseBoolAttr(val)
}

// SetDefSemiHidden sets the "w:defSemiHidden" attribute.
// Passing false removes it.
func (e *CT_LatentStyles) SetDefSemiHidden(v bool) error {
	if v == false {
		e.RemoveAttr("w:defSemiHidden")
		return nil
	}
	s, err := formatBoolAttr(v)
	if err != nil {
		return fmt.Errorf("CT_LatentStyles.SetDefSemiHidden: %w", err)
	}
	e.SetAttr("w:defSemiHidden", s)
	return nil
}

// DefUIPriority returns the value of the "w:defUIPriority" attribute, or 0 if absent.
// Returns an error if the attribute is present but cannot be parsed.
func (e *CT_LatentStyles) DefUIPriority() (int, error) {
	val, ok := e.GetAttr("w:defUIPriority")
	if !ok {
		return 0, nil
	}
	parsed, err := parseIntAttr(val)
	if err != nil {
		return 0, &ParseAttrError{Element: e.Tag(), Attr: "w:defUIPriority", RawValue: val, Err: err}
	}
	return parsed, nil
}

// SetDefUIPriority sets the "w:defUIPriority" attribute.
// Passing 0 removes it.
func (e *CT_LatentStyles) SetDefUIPriority(v int) error {
	if v == 0 {
		e.RemoveAttr("w:defUIPriority")
		return nil
	}
	s, err := formatIntAttr(v)
	if err != nil {
		return fmt.Errorf("CT_LatentStyles.SetDefUIPriority: %w", err)
	}
	e.SetAttr("w:defUIPriority", s)
	return nil
}

// DefUnhideWhenUsed returns the value of the "w:defUnhideWhenUsed" attribute, or false if absent.
func (e *CT_LatentStyles) DefUnhideWhenUsed() bool {
	val, ok := e.GetAttr("w:defUnhideWhenUsed")
	if !ok {
		return false
	}
	return parseBoolAttr(val)
}

// SetDefUnhideWhenUsed sets the "w:defUnhideWhenUsed" attribute.
// Passing false removes it.
func (e *CT_LatentStyles) SetDefUnhideWhenUsed(v bool) error {
	if v == false {
		e.RemoveAttr("w:defUnhideWhenUsed")
		return nil
	}
	s, err := formatBoolAttr(v)
	if err != nil {
		return fmt.Errorf("CT_LatentStyles.SetDefUnhideWhenUsed: %w", err)
	}
	e.SetAttr("w:defUnhideWhenUsed", s)
	return nil
}

// --- CT_LsdException ---

// CT_LsdException — latent style exception element
type CT_LsdException struct {
	Element
}

// Locked returns the value of the "w:locked" attribute, or false if absent.
func (e *CT_LsdException) Locked() bool {
	val, ok := e.GetAttr("w:locked")
	if !ok {
		return false
	}
	return parseBoolAttr(val)
}

// SetLocked sets the "w:locked" attribute.
// Passing false removes it.
func (e *CT_LsdException) SetLocked(v bool) error {
	if v == false {
		e.RemoveAttr("w:locked")
		return nil
	}
	s, err := formatBoolAttr(v)
	if err != nil {
		return fmt.Errorf("CT_LsdException.SetLocked: %w", err)
	}
	e.SetAttr("w:locked", s)
	return nil
}

// QFormat returns the value of the "w:qFormat" attribute, or false if absent.
func (e *CT_LsdException) QFormat() bool {
	val, ok := e.GetAttr("w:qFormat")
	if !ok {
		return false
	}
	return parseBoolAttr(val)
}

// SetQFormat sets the "w:qFormat" attribute.
// Passing false removes it.
func (e *CT_LsdException) SetQFormat(v bool) error {
	if v == false {
		e.RemoveAttr("w:qFormat")
		return nil
	}
	s, err := formatBoolAttr(v)
	if err != nil {
		return fmt.Errorf("CT_LsdException.SetQFormat: %w", err)
	}
	e.SetAttr("w:qFormat", s)
	return nil
}

// SemiHidden returns the value of the "w:semiHidden" attribute, or false if absent.
func (e *CT_LsdException) SemiHidden() bool {
	val, ok := e.GetAttr("w:semiHidden")
	if !ok {
		return false
	}
	return parseBoolAttr(val)
}

// SetSemiHidden sets the "w:semiHidden" attribute.
// Passing false removes it.
func (e *CT_LsdException) SetSemiHidden(v bool) error {
	if v == false {
		e.RemoveAttr("w:semiHidden")
		return nil
	}
	s, err := formatBoolAttr(v)
	if err != nil {
		return fmt.Errorf("CT_LsdException.SetSemiHidden: %w", err)
	}
	e.SetAttr("w:semiHidden", s)
	return nil
}

// UiPriority returns the value of the "w:uiPriority" attribute, or 0 if absent.
// Returns an error if the attribute is present but cannot be parsed.
func (e *CT_LsdException) UiPriority() (int, error) {
	val, ok := e.GetAttr("w:uiPriority")
	if !ok {
		return 0, nil
	}
	parsed, err := parseIntAttr(val)
	if err != nil {
		return 0, &ParseAttrError{Element: e.Tag(), Attr: "w:uiPriority", RawValue: val, Err: err}
	}
	return parsed, nil
}

// SetUiPriority sets the "w:uiPriority" attribute.
// Passing 0 removes it.
func (e *CT_LsdException) SetUiPriority(v int) error {
	if v == 0 {
		e.RemoveAttr("w:uiPriority")
		return nil
	}
	s, err := formatIntAttr(v)
	if err != nil {
		return fmt.Errorf("CT_LsdException.SetUiPriority: %w", err)
	}
	e.SetAttr("w:uiPriority", s)
	return nil
}

// UnhideWhenUsed returns the value of the "w:unhideWhenUsed" attribute, or false if absent.
func (e *CT_LsdException) UnhideWhenUsed() bool {
	val, ok := e.GetAttr("w:unhideWhenUsed")
	if !ok {
		return false
	}
	return parseBoolAttr(val)
}

// SetUnhideWhenUsed sets the "w:unhideWhenUsed" attribute.
// Passing false removes it.
func (e *CT_LsdException) SetUnhideWhenUsed(v bool) error {
	if v == false {
		e.RemoveAttr("w:unhideWhenUsed")
		return nil
	}
	s, err := formatBoolAttr(v)
	if err != nil {
		return fmt.Errorf("CT_LsdException.SetUnhideWhenUsed: %w", err)
	}
	e.SetAttr("w:unhideWhenUsed", s)
	return nil
}

// Name returns the value of the required "w:name" attribute.
func (e *CT_LsdException) Name() (string, error) {
	val, ok := e.GetAttr("w:name")
	if !ok {
		return "", fmt.Errorf("required attribute %q not present on <%s>", "w:name", e.Tag())
	}
	return val, nil
}

// SetName sets the required "w:name" attribute.
func (e *CT_LsdException) SetName(v string) error {
	s, err := formatStringAttr(v)
	if err != nil {
		return fmt.Errorf("CT_LsdException.SetName: %w", err)
	}
	e.SetAttr("w:name", s)
	return nil
}
