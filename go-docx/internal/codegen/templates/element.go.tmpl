// Code generated by codegen; DO NOT EDIT.

package {{.Package}}

import (
	"fmt"
{{- range .Imports}}
	"{{.}}"
{{- end}}
)

// Ensure imports are used.
var _ = fmt.Sprintf
{{range .Elements}}
// --- {{.Name}} ---

// {{.Name}}{{if .Doc}} â€” {{.Doc}}{{end}}
type {{.Name}} struct {
	Element
}
{{range .ZeroOrOneChildren}}
// {{.GoName}} returns the <{{.Tag}}> child element, or nil if not present.
func (e *{{.ParentType}}) {{.GoName}}() *{{.Type}} {
	child := e.FindChild("{{.Tag}}")
	if child == nil {
		return nil
	}
	return &{{.Type}}{Element{e: child}}
}

// GetOrAdd{{.GoName}} returns <{{.Tag}}>, creating it if not present.
func (e *{{.ParentType}}) GetOrAdd{{.GoName}}() *{{.Type}} {
	child := e.{{.GoName}}()
	if child != nil {
		return child
	}
	return e.add{{.GoName}}()
}

// Remove{{.GoName}} removes all <{{.Tag}}> child elements.
func (e *{{.ParentType}}) Remove{{.GoName}}() {
	e.RemoveAll("{{.Tag}}")
}

// add{{.GoName}} adds a new <{{.Tag}}> in correct sequence.
func (e *{{.ParentType}}) add{{.GoName}}() *{{.Type}} {
	child := e.new{{.GoName}}()
	e.insert{{.GoName}}(child)
	return child
}

// new{{.GoName}} creates a detached <{{.Tag}}> element.
func (e *{{.ParentType}}) new{{.GoName}}() *{{.Type}} {
	el := OxmlElement("{{.Tag}}")
	return &{{.Type}}{Element{e: el}}
}

// insert{{.GoName}} inserts child before first successor.
func (e *{{.ParentType}}) insert{{.GoName}}(child *{{.Type}}) *{{.Type}} {
	e.InsertElementBefore(child.e{{range .Successors}}, "{{.}}"{{end}})
	return child
}
{{end}}{{range .ZeroOrMoreChildren}}
// {{.GoName}}List returns all <{{.Tag}}> child elements.
func (e *{{.ParentType}}) {{.GoName}}List() []*{{.Type}} {
	children := e.FindAllChildren("{{.Tag}}")
	result := make([]*{{.Type}}, len(children))
	for i, c := range children {
		result[i] = &{{.Type}}{Element{e: c}}
	}
	return result
}

// Add{{.GoName}} adds a new <{{.Tag}}> in correct sequence.
func (e *{{.ParentType}}) Add{{.GoName}}() *{{.Type}} {
	return e.add{{.GoName}}()
}

// add{{.GoName}} adds a new <{{.Tag}}> unconditionally in correct sequence.
func (e *{{.ParentType}}) add{{.GoName}}() *{{.Type}} {
	child := e.new{{.GoName}}()
	e.insert{{.GoName}}(child)
	return child
}

// new{{.GoName}} creates a detached <{{.Tag}}> element.
func (e *{{.ParentType}}) new{{.GoName}}() *{{.Type}} {
	el := OxmlElement("{{.Tag}}")
	return &{{.Type}}{Element{e: el}}
}

// insert{{.GoName}} inserts child before first successor.
func (e *{{.ParentType}}) insert{{.GoName}}(child *{{.Type}}) *{{.Type}} {
	e.InsertElementBefore(child.e{{range .Successors}}, "{{.}}"{{end}})
	return child
}
{{end}}{{range .OneAndOnlyOneChildren}}
// {{.GoName}} returns the required <{{.Tag}}> child element.
// Returns an error if not present (invalid XML).
func (e *{{.ParentType}}) {{.GoName}}() (*{{.Type}}, error) {
	child := e.FindChild("{{.Tag}}")
	if child == nil {
		return nil, fmt.Errorf("required <%s> child not present in <%s>", "{{.Tag}}", e.Tag())
	}
	return &{{.Type}}{Element{e: child}}, nil
}
{{end}}{{range .OneOrMoreChildren}}
// {{.GoName}}List returns all <{{.Tag}}> child elements.
// At least one must be present in valid XML.
func (e *{{.ParentType}}) {{.GoName}}List() []*{{.Type}} {
	children := e.FindAllChildren("{{.Tag}}")
	result := make([]*{{.Type}}, len(children))
	for i, c := range children {
		result[i] = &{{.Type}}{Element{e: c}}
	}
	return result
}

// Add{{.GoName}} adds a new <{{.Tag}}> in correct sequence.
func (e *{{.ParentType}}) Add{{.GoName}}() *{{.Type}} {
	return e.add{{.GoName}}()
}

// add{{.GoName}} adds a new <{{.Tag}}> unconditionally in correct sequence.
func (e *{{.ParentType}}) add{{.GoName}}() *{{.Type}} {
	child := e.new{{.GoName}}()
	e.insert{{.GoName}}(child)
	return child
}

// new{{.GoName}} creates a detached <{{.Tag}}> element.
func (e *{{.ParentType}}) new{{.GoName}}() *{{.Type}} {
	el := OxmlElement("{{.Tag}}")
	return &{{.Type}}{Element{e: el}}
}

// insert{{.GoName}} inserts child before first successor.
func (e *{{.ParentType}}) insert{{.GoName}}(child *{{.Type}}) *{{.Type}} {
	e.InsertElementBefore(child.e{{range .Successors}}, "{{.}}"{{end}})
	return child
}
{{end}}{{range .OptionalAttributes}}
{{- if .Failable}}
// {{.GoName}} returns the value of the "{{.AttrName}}" attribute, or {{.DefaultExpr}} if absent.
// Returns an error if the attribute is present but cannot be parsed.
func (e *{{.ParentType}}) {{.GoName}}() ({{.GoType}}, error) {
	val, ok := e.GetAttr("{{.AttrName}}")
	if !ok {
		return {{.DefaultExpr}}, nil
	}
	parsed, err := {{.ParseExpr}}
	if err != nil {
		return {{.DefaultExpr}}, &ParseAttrError{Element: e.Tag(), Attr: "{{.AttrName}}", RawValue: val, Err: err}
	}
	return {{if .IsPointer}}&parsed{{else}}parsed{{end}}, nil
}
{{- else}}
// {{.GoName}} returns the value of the "{{.AttrName}}" attribute, or {{.DefaultExpr}} if absent.
func (e *{{.ParentType}}) {{.GoName}}() {{.GoType}} {
	val, ok := e.GetAttr("{{.AttrName}}")
	if !ok {
		return {{.DefaultExpr}}
	}
	return {{.ParseExpr}}
}
{{- end}}

// Set{{.GoName}} sets the "{{.AttrName}}" attribute.
// Passing {{.DefaultExpr}} removes it.
func (e *{{.ParentType}}) Set{{.GoName}}(v {{.GoType}}) error {
	if v == {{.DefaultExpr}} {
		e.RemoveAttr("{{.AttrName}}")
		return nil
	}
	s, err := {{.FormatExpr}}
	if err != nil {
		return fmt.Errorf("{{.ParentType}}.Set{{.GoName}}: %w", err)
	}
	e.SetAttr("{{.AttrName}}", s)
	return nil
}
{{end}}{{range .RequiredAttributes}}
{{- if .Failable}}
// {{.GoName}} returns the value of the required "{{.AttrName}}" attribute.
func (e *{{.ParentType}}) {{.GoName}}() ({{.GoType}}, error) {
	val, ok := e.GetAttr("{{.AttrName}}")
	if !ok {
		return {{.ZeroExpr}}, fmt.Errorf("required attribute %q not present on <%s>", "{{.AttrName}}", e.Tag())
	}
	parsed, err := {{.ParseExpr}}
	if err != nil {
		return {{.ZeroExpr}}, &ParseAttrError{Element: e.Tag(), Attr: "{{.AttrName}}", RawValue: val, Err: err}
	}
	return parsed, nil
}
{{- else}}
// {{.GoName}} returns the value of the required "{{.AttrName}}" attribute.
func (e *{{.ParentType}}) {{.GoName}}() ({{.GoType}}, error) {
	val, ok := e.GetAttr("{{.AttrName}}")
	if !ok {
		return {{.ZeroExpr}}, fmt.Errorf("required attribute %q not present on <%s>", "{{.AttrName}}", e.Tag())
	}
	return {{.ParseExpr}}, nil
}
{{- end}}

// Set{{.GoName}} sets the required "{{.AttrName}}" attribute.
func (e *{{.ParentType}}) Set{{.GoName}}(v {{.GoType}}) error {
	s, err := {{.FormatExpr}}
	if err != nil {
		return fmt.Errorf("{{.ParentType}}.Set{{.GoName}}: %w", err)
	}
	e.SetAttr("{{.AttrName}}", s)
	return nil
}
{{end}}{{range .ChoiceGroups}}
// {{.GoName}} returns the child element belonging to this choice group,
// or nil if no member child is present.
func (e *{{.ParentType}}) {{.GoName}}() *Element {
	child := e.FirstChildIn({{range $i, $t := .Tags}}{{if $i}}, {{end}}"{{$t}}"{{end}})
	if child == nil {
		return nil
	}
	return &Element{e: child}
}

// Remove{{.GoName}} removes the current choice group child element if present.
func (e *{{.ParentType}}) Remove{{.GoName}}() {
	e.RemoveAll({{range $i, $t := .Tags}}{{if $i}}, {{end}}"{{$t}}"{{end}})
}
{{range .Choices}}
// {{.GoName}} returns the <{{.Tag}}> choice member, or nil if not present.
func (e *{{.ParentType}}) {{.GoName}}() *{{.Type}} {
	child := e.FindChild("{{.Tag}}")
	if child == nil {
		return nil
	}
	return &{{.Type}}{Element{e: child}}
}

// GetOrChangeTo{{.GoName}} returns the <{{.Tag}}> child, replacing any other
// group element if found.
func (e *{{.ParentType}}) GetOrChangeTo{{.GoName}}() *{{.Type}} {
	child := e.{{.GoName}}()
	if child != nil {
		return child
	}
	e.Remove{{.GroupName}}()
	return e.add{{.GoName}}()
}

// add{{.GoName}} adds a new <{{.Tag}}> in correct sequence.
func (e *{{.ParentType}}) add{{.GoName}}() *{{.Type}} {
	child := e.new{{.GoName}}()
	e.insert{{.GoName}}(child)
	return child
}

// new{{.GoName}} creates a detached <{{.Tag}}> element.
func (e *{{.ParentType}}) new{{.GoName}}() *{{.Type}} {
	el := OxmlElement("{{.Tag}}")
	return &{{.Type}}{Element{e: el}}
}

// insert{{.GoName}} inserts child before first successor.
func (e *{{.ParentType}}) insert{{.GoName}}(child *{{.Type}}) *{{.Type}} {
	e.InsertElementBefore(child.e{{range .Successors}}, "{{.}}"{{end}})
	return child
}
{{end}}{{end}}{{end}}
